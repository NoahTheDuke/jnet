Terminology:

Note that "changing the game state" does not include adding things to the queue or otherwise manipulating the internal state of the engine. It means in game state.

Effect Step: Basic indivisible units of game state change. Things like drawing cards, gaining credits or the steps of a timing structure fall into this. No other steps may change the game state. 
Blocking Step: A step that causes the engine to stop what it's doing and wait for something. Usually it'll be waiting on a user because of a prompt. 
Guard Step: A step that does nothing in itself but that can be aborted to by a special effect step. Each guard step has a keyword type associated with it. 
Composite Step: All other steps. These steps never do anything other than add steps to the queue, potentially after examining the game state. simple-step gives composite steps.
Composite Call: A composite step that can be used directly, in addition to queuing it. Composite calls should not depend on game state. Note that the distinction between a composition step and a composite call is in how the revelant function is defined not in how it is used. 

Prompt Step: A blocking step. Displays a custom prompt to the user. 
PAW Step: A blocking step. Represents a paid ability window. 
Action Step: A blocking step. Represents the action phase ability window. 

Interrupt Check Step: A composite step. Represents an interrupt window. 

Checkpoint Step: An effect step. Must be requested manually when required by the engine or cards. Acts as a blocking step for the purposes of the pending instruction.
Imminent Instruction: The series of steps between the start of the pipeline and the next blocking step or checkpoint step. 
Expected Effects: The results of a process via which the interrupt system determines which effect steps will run before the next checkpoint.

#I think this is the best way to handle checkpoints and pending instructions.

Pipeline: The pipeline system itself. It just knows how to click prompts, build diffs and run steps.
Core: The suite supporting functions/macros that allow you to manipulate the pipeline easily. 
Engine: The game rules. Timing steps, effects and functions for examining the state.
Cards: The cards.

-----------

pipeline Workings:
The pipeline runs with a simple (swap! @game handle-prompt-clicked action). handle-prompt-clicked will give the action to the prompt at the beginning of the pipeline then call continue-game.

Each invocation other than the first, the kernel expects to be given the action (e.g. prompt click) that caused the invocation. This action is passed to the prompt-clicked method of the first step in the queue prior to the main iteration being performed.

Each iteration of continue-game performs the following steps:
Call update-game.
Call the blocking method of the next step in the queue. If it returns false, continue to the next step, otherwise return whatever the blocking method returned, which should be the game state inc prompt.
If it returned false, update the game using the continue-step method of the next step and go to the next iteration. 

--------

Engine Workings:
The majority of engine functions will either be game state reporting functions, which will be hopefully mostly unchanged, or composite steps/calls.

Composite calls mostly follow the form (-> game (step) (step) (step)) and can be defined with a simple defn. They are the simplest and lightest of "steps" in that they needn't be backed by a step record or enter the pipeline at all. Though often they are, which is called a composite step. 

Example:

(defn example-composite-call [game some args whatever] (-> game (other-step some args) (more-step whatever)))

As you can see if other-step and more-step were composite calls themselves with similar definitions they'd just immediately have their effect. This is safe because composite steps can only change the pipeline. They have no way to cause triggers or prompts. This means that composite steps are usually expanded before they ever hit the queue. Some composite steps must be true steps, mostly to allow the ablity to (queue-step this) and recur. This method of recursion is the main looping mechanism for the game. 

The signature of the functions used is the same in either case, as with all steps. That same composite call as a true step is instead defined (probably via a macro) like so:

(defn example-composite-step [game some args whatever] (-> game (queue-simple-step (other-step some args) (more-step whatever))))

Either way the process for using them is the same as with all steps. Just thread game through the function. 

Prompt Steps:
Prompts can have any structure really, so long as the users click can be mapped to a step we're good. Prompt steps, like all steps, should define at least one function that you can thread game through and get them added to the queue. Prompts are thing most likely to want to define more functions for different cases. Most stuff should be able to use pretty simple versions though. 

PAW Step:
A prompt step that displays a pass button and activates relevant paid abilities/rezzing etc. 

Action Step:
Similar to the PAW step but displays the basic action card.

Interrupt Check Step:
A composite step for interrupts. Interrupts are probably the most complicated part of the rules and consequently the engine.
This step is not usually manually used by card or engine effects. Instead, as detailed below, it is used as part of resolving a step made with the def-effect-full macro.

First, we calculate the expected effects of the imminent instruction. 
This is done by setting the :expected key in game to an empty list and then calling continue-game. 
The presence of :expected causes checkpoints to become blocking and effect steps to append themselves to the :expected list when they run. 
#I don't think there's an official ruling on if the effect steps should still be changing the state as well. It's utterly moot I think. It's no skin either way for us though.
After extracting the :expected list from the returned game state the rest is discarded. 

The :expected list is checked against each active interrupt ability for relevance. If none are found, the check is over, disable interrupts (they will be enabled again at the next checkpoint). 
If some are found, do a stanrd set of prompts/PAW to resolve them, disable interrupts and continue.

def-effect-full macro:
This macro is used to declare effect steps with all the bells and whistles. It has the same syntax as defn. If the first argument is not "game" it errors. 

Using defstep will define a new step record/schema with a name created from the function name. So draw will produce DrawStep. 

This record will have extra properties with names that correspond to the arguments of the function, excepting game of course. 

An entry will be created in the triggers and interrupts lists based on the function name. So draw will produce :runner-draw and :corp-draw in both lists. Modifiers can change these names or suppress some or all of this behaviour. The names are stored in properties of the record. 

A new function will be defined with the function name and arguments as given. This function will check for relevant prevention effects, if none are found create a new instance of the step, setting the extra properties appropriately to its arguments and queue it. 

When the continue-step of this new step is called it will first check if interrupts are disabled.
If they are not it will queue an interrupt check step, then itself then return. 

After the interrupt check, execute the function body, passing in the arguments from the properties.

Then do a trigger check in line with the interrupt check, but you just add relevant triggers to the trigger queue (not to be confused with the main queue). 

def-effect-triggers: same as def-effect-full but disables stuff other than triggers, useful for start of turn or similar.

def-effect-light: disables all the fancy stuff, useful for random timing structure steps or not really game actions like writing to the log

-----------

let-step macro: This macro gives you access to the results of a step. A step can use (set-result game result) to give a result, which can then be bound to a symbol with the let-step macro.
Internally this works via set-result just putting the value in :return-value in game. The let-step macro will first handle its bindings. For each one it queues a step that just calls (set-result nil), then queues the given binding, then queues something that takes the :return-value from game and puts it in an atom. Then it will wrap its body in something that derefs the atoms and binds them to the right symbols.  

-----------

