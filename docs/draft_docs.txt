Terminology:

Note that "changing the game state" does not include adding things to the queue or otherwise manipulating the internal state of the engine. It means in game state.  

Effect Step: Basic indivisible units of game state change. Things like drawing cards, gaining credits or the steps of a timing structure fall into this.  
Blocking Step: A step that causes the engine to stop what it's doing and wait for something. Usually it'll be waiting on a user because of a prompt. 
Guard Step: A step that is aborted to by the abort step (which is an effect step). Any step type can be used for this purpose. 
Composite Step: All other steps. These steps never do anything other than add steps (including effect steps) to the queue, potentially after examining the game state. simple-step gives composite steps.
Composite Call: A composite step that can be used directly, in addition to queuing it. Composite calls should not depend on game state. Note that the distinction between a composition step and a composite call is in how the revelant function is defined not in how it is used. 

Prompt Step: A blocking step. Displays a custom prompt to the user. 
PAW Step: A blocking step. Represents a paid ability window. 
Action Step: A blocking step. Represents the action phase ability window. 

Interrupt Check Step: A composite step. Represents an interrupt window. Note it's composite even though it can block and change the game state, because it uses other prompts and effects to do that.

Checkpoint Step: An effect step. Must be requested manually when required by the engine or cards. Acts as a blocking step for the purposes of the imminent instruction. 
Imminent Instruction: The series of steps between the start of the pipeline and the next blocking step or checkpoint step. 
Expected Effects: The results of a process via which the interrupt system determines which effect steps will run before the next checkpoint. 

Core: The pipeline system itself and the related helper functions/macros for interacting with it.
Engine: The game rules and systems. The dividing line between the core and the engine is that the engine does not interact with the pipeline directly and so can be reasoned about using the rules below.
Cards: The card code, it follows the same rules as the engine wrt pipeline management.

-----------

Pipeline Workings:
The pipeline runs with a simple (swap! @game handle-prompt-clicked player action). handle-prompt-clicked will give the action to the prompt at the beginning of the pipeline then call continue-game.

On each invocation after the first, the kernel expects to be given the action (e.g. prompt click) that caused the invocation. This action is passed to the prompt-clicked method of the first step in the queue prior to the main iteration being performed.

Each iteration of continue-game performs the following steps:
Call update-pipeline.
Call blocking on the next step in the queue. If it returned false, update the game using the continue-step method and go to the next iteration. 
If it doesn't return false, return whatever the blocking method returned, which should be the game state inc prompt.

--------

Engine Workings:
The majority of engine functions will either be game state reporting functions, which will be hopefully mostly unchanged, or composite steps/calls. 

The main advantage of the engine's structure is that it lets you reason about your code as if it were synchronous. If you make the substitutions outlined here, the results will be identical:
Pretend that queuing a step is running it immediately.
Pretend that prompts genuinely block.
Pretend that (queue-step this) is (recur). With the innermost (as-step acting as (loop. If you'd like to recur to an outer as-step, use (as-step (let [named-loop this]...(queue-step named-loop).
#No arguments to recur atm, might look into this at some point.
Pretend that (let-step is a weird version of (let that you thread game through, it will then thread game through your bindings and takes results from the last call to (set-result.
Pretend that the way to get up to date data from game as you're threading it is (as-step rather than ((fn [game].
Pretend that guard steps and aborting are try/catch blocks. 

With these substitutions any reasoning you make about what will run in what order or what values will be what at which points will be identical to synchronous code with one caveat. If you write:

(defn draw-for-programs 
	  [game player]
	  (-> game 
	      (draw player (programs-in-play game))))

The state that programs-in-play is examining may be stale, much as if you tried to examine it halfway through a thread. This can be avoided by declaring the function with defstep, which simply wraps the function body in (as-step game), which itself wraps around queue-simple-step, providing access to the "this" variable in the process. 

Note that you may still use (let normally when you just want a simple return value rather than a set-result. Just take care that the state of game is up to date by wrapping it in (as-step. 

Composite calls mostly follow the form (-> game (action) (action) (action)) and can be defined with a simple defn. They are the simplest and lightest of "steps" in that they needn't be backed by a step record or enter the pipeline at all. 

Example:

(defn example-composite-call [game some args whatever] (-> game (other-step some args) (more-step whatever)))

If a something examines the game state or recurs, it's known as a composite step and must be defined as a proper step. Like with altering the game state examining the game state is something you must do directly to qualify. A function that draws cards until your hand is full would count because it looks at how many cards you have in hand (i.e. a value that could be altered if there are draw steps in the pipeline). As such this function should be defined as one that queues a step (e.g. via defstep/as-step). The effect of the card Game Day would not count and can be implemented as a simple function, because it can just call that function. Likewise, a good number of cards can be implemented as simple functions. 

We should take care that examinations of state are tightly wrapped in steps, the rule for safety can be summed up as "if you use the game variable other than the normal threading it, you need to wrap that line (i.e. back to where you are threading game) in as-step," just the same as you need to wrap it in ((fn [game] in sync code, though the out of date version you get goes back to the innermost step, not the innermost function. This is mostly moot as the knowledge that any effect could cause any trigger which makes any state change is enough that you always need to do (as-step/fn [game] there anyway. 

Composite steps that wish to recur must be defined as a proper step and should use (queue-step this) to achieve this. Both the defstep and as-step macros bind the variable this (ed note: considering binding something that just lets you recur, "this" shouldn't really be used for anything else). A defn like macro defstep is provided that makes any function a step or the as-step macro provides inline steps. For instance, this function can be safely defined with a simple defn:

(defn simple-call [game] (-> game (blah) (blah) (blah) (as-step (some-effect game (examine-state game))) (blah) (blah) (blah)))

Or showing recursion over a prompt:

(defstep check-mu-usage [game]
  (if (mu-limit-exceeded game)
      (-> game
          (trash-program-prompt)
          (queue-step this))
      game))


Prompt Steps:
Prompts can have any structure really, so long as the users click can be mapped to a function we're good. Prompt steps, like all steps, should have at least one helper function that you can thread game through and get them added to the queue. Prompts are the thing most likely to want to define more functions for different cases. Most stuff should be able to use pretty simple versions though. 

PAW Step:
A prompt step that displays a pass button and activates relevant paid abilities/rezzing etc. 

Action Step:
Similar to the PAW step but displays the basic action card. 

Interrupt Check Step:
A composite step for interrupts. Interrupts are probably the most complicated part of the rules and consequently the engine.
This step is not usually manually used by card or engine effects. Instead, as detailed below, it is used as part of resolving a step made with the defeffect macro.

First, we calculate the expected effects of the imminent instruction. 
This is done by setting the :expected-effects key in game to an empty list and then calling continue-game. 
The presence of :expected causes checkpoints to become blocking and effect steps to append themselves to the :expected list when they run. 
#I don't think there's an official ruling on if the effect steps should still be changing the state as well. It's utterly moot I think. It's no skin either way for us though.
After extracting the :expected-effects list from the returned game state the rest is discarded. 

The :expected list is checked against each active interrupt ability for relevance. If none are found, the check is over, disable interrupts (they will be enabled again at the next checkpoint). 
If some are found, do a standard set of trigger prompts/PAW steps to resolve them, disable interrupts and continue.

------------

Core workings:

defeffect-full macro:
This macro is used to declare effect steps with all the bells and whistles. It has the same syntax as defn. If the first argument is not "game" it errors. 

An entry will be created in the triggers, interrupts and prevention lists based on the function name. So draw will produce :runner-draw, :corp-draw and :draw in all lists. Modifiers can change these names or suppress some of this behaviour. 

A new function will be defined with the function name and arguments as given. This function simply creates a new instance of EffectStep with appropriate properties, including trigger names and the arguments to the function call, and queues it. 

When the continue-step of this new step is called it will first check if there's an applicable prevention effect, and simply return if so.
Then it will check if interrupts are disabled. If they are not it will queue an interrupt check step, then queue itself then return. 

If interrupts are disabled, execute the function body, passing in the arguments that were stored in EffectStep when it was created.

Then do a trigger check, adding relevant triggers to the trigger queue (not to be confused with the main queue). 

defeffect-triggers: same as def-effect-full but disables stuff other than triggers, useful for start of turn or similar.

defeffect: disables all the fancy stuff, useful for random timing structure steps or not really game actions that we still want to treat as one like writing to the log.

let-step macro: This macro gives you access to the results of a step. A step can use set-result to give a result, which can then be bound to a symbol with the let-step macro.
Internally this works via set-result just putting the value in :step-result in game. The let-step macro will first recursively deconstruct itself into let-steps with a single binding each. Then it queues a step that just calls (set-result nil), then queues the given bindings value, then queues something that takes the :step-result from game and puts it in an atom. Then it will wrap its body in something that derefs the atom and binds the right symbol.  
